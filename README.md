# Introduction
This Python-based power system analysis program addresses the complexity of understanding large power networks using the Newton-Raphson method of solving nonlinear equations. It offers insights into power flow through simulated transmission scenarios, allowing for understanding and developing contingency plans for different scenarios. This project was a part of a Power System Analysis class.
# Program Description
The program uses an object-oriented approach in which several objects represent a fundamental component or concept within the simulated power system analysis problem.
The main method, the entry point of the program program, serves as the description of the required base and contingency scenarios. It uses the provided Excel file, “system_basecase.xlsx,” as input and outputs another Excel file, “system_output.xlsx,” which displays the results of the required scenarios. The global_settings.py file contains crucial data and settings such as the complex base power, the mismatch precision, and upper and lower bus voltage limits.
## Input / Output Classes
These classes of objects contain the representations of the input and output Excel files. The DataReader class gathers data and instantiates the data classes in arrays, while the DataWriter class writes the required outputs after the data has been operated on for each scenario. Each class can be adjusted as an optional setting to take or output a different filename.
## Data Classes
The LineData and BusData classes represent a model for the physical lines or buses in the power system. These data classes have both gettable properties and a few setter properties, which are further detailed below.

The line data object contains the following public properties: the connected buses, maximum bus ID, the calculated power going to and from the buses in the connection, the state of the line (if the line is on, off, or if one of two circuits is off), its type (transformer or transmission line), and overload status. Additional attributes that were input from the DataReader class are not accessible and are private to the internal operations in the line object, such as the reactance and resistance of the line, but are used in the line power calculations. Two functions define the functionality of the line data object. The y_stamp function defines the publicly accessible functionality of the line data object, which is linked to the NodalAnalysis class and is further defined in that section. Meanwhile, the line_flow_calc function defines the private functionality that calculates the line flow in both directions accessible by the power properties of the line.

The bus data object contains the following public properties: the bus identifier, active and reactive power (totals, generated, and load), voltage, voltage angle, and the voltage limit check status. As the power analysis operation runs, the appropriate properties are updated for each bus with the setter properties, which may only be adjusted depending on the defined bus type to prevent unintended errors.
## Analysis Classes
The analysis classes, comprised of NodalAnalysis and PowerAnalysis, contain the program's data operation portion, which transforms the input data into the output data.

The nodal analysis object receives input for the list of LineData created by a DataReader object. Using the total number of buses in the network to define the size of the compiled admittance matrix, each LineData object creates a sparse admittance matrix that contains only that line. These individual line admittance matrices are then compiled into the system admittance matrix by adding each line iteratively in the NodalAnalysis object. The compiled admittance matrix is then accessible by the y_matrix property.

The power analysis operation uses the Newton-Raphson method to solve the power flow equations and find the steady state of the power system for the given scenario. To do so, the power analysis object has one public function, update, which takes the admittance matrix from a nodal analysis object as input. This primary function is then broken down into several private functions which perform each part of the Newton-Raphson method. The first private function solves the implicit equations related to the PQ and PV buses through the iterative approach that the Newton-Raphson method requires. The implicit equation function first computes the mismatch equations, determining the power at both PQ and PV buses. A series of Jacobian matrix functions are employed to construct an inverse Jacobian matrix. Multiplying this inverse Jacobian with the outcome of the mismatch equations yields the delta adjustment necessary for the voltage and angle at the buses, thereby facilitating convergence toward the solution. The delta adjustment is then applied to the BusData objects and repeats within the implicit equation function until the mismatch equations are significantly minimized. Finally, the second private function solves the explicit equations related to the slack and PV buses from the updated PV and PQ bus data, and the update function completes with all buses having their final power and voltage data.
